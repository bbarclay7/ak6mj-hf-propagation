{% extends "base.html" %}

{% block title %}WSPR - Antenna Comparison{% endblock %}

{% block head %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
    #map {
        height: 500px;
        width: 100%;
        margin-bottom: 2rem;
    }
    #azimuthal-map {
        width: 100%;
        display: flex;
        justify-content: center;
        overflow: hidden;
    }
    #azimuthal-map svg {
        max-width: 100%;
        height: auto;
    }
    .az-controls {
        display: flex;
        gap: 1rem;
        margin-bottom: 0.5rem;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
    }
    .az-controls button {
        padding: 0.25rem 0.75rem;
        background: #2a2a2a;
        border: 1px solid #444;
        color: #aaa;
        cursor: pointer;
        border-radius: 4px;
    }
    .az-controls button:hover {
        background: #3a3a3a;
    }
    .az-slider-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .az-slider-container input[type="range"] {
        width: 200px;
        cursor: pointer;
    }
    .az-slider-label {
        color: #888;
        font-size: 0.85rem;
        min-width: 80px;
    }
    .map-tabs {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
    }
    .map-tab {
        padding: 0.5rem 1rem;
        background: #2a2a2a;
        border: none;
        color: #aaa;
        cursor: pointer;
        border-radius: 4px;
    }
    .map-tab.active {
        background: #4fc3f7;
        color: #000;
    }
    #mercator-container, #azimuthal-container {
        display: none;
    }
    #mercator-container.active, #azimuthal-container.active {
        display: block;
    }
    .wspr-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
    }
    .stat-card {
        background: #f5f5f5;
        padding: 1rem;
        border-radius: 4px;
        text-align: center;
    }
    .stat-value {
        font-size: 2rem;
        font-weight: bold;
        color: #2563eb;
    }
    .stat-label {
        color: #666;
        font-size: 0.9rem;
        margin-top: 0.5rem;
    }
    .spots-table {
        width: 100%;
        border-collapse: collapse;
    }
    .spots-table th,
    .spots-table td {
        padding: 0.75rem;
        text-align: left;
        border-bottom: 1px solid #e5e7eb;
    }
    .spots-table th {
        background: #f9fafb;
        font-weight: 600;
    }
    .snr-good { color: #16a34a; }
    .snr-ok { color: #ca8a04; }
    .snr-weak { color: #dc2626; }
    .tx-location {
        font-weight: 600;
        color: #2563eb;
    }
    #antenna-selector {
        display: flex;
        gap: 2rem;
        align-items: start;
        flex-wrap: wrap;
    }
    .antenna-info {
        flex: 1;
        min-width: 300px;
    }
    .antenna-name {
        font-size: 1.5rem;
        font-weight: bold;
        color: #4fc3f7;
        margin-bottom: 0.5rem;
    }
    .antenna-desc {
        color: #aaa;
        margin-bottom: 0.5rem;
        line-height: 1.6;
    }
    .antenna-updated {
        font-size: 0.85rem;
        color: #666;
    }
    .antenna-controls {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        min-width: 300px;
    }
    .antenna-controls select {
        flex: 1;
    }
    .stat-detail {
        font-size: 0.75rem;
        color: #888;
        margin-top: 0.25rem;
    }
    .beacon-active { border-left: 4px solid #16a34a; }
    .beacon-stale { border-left: 4px solid #ca8a04; }
    .beacon-offline { border-left: 4px solid #dc2626; }
</style>
{% endblock %}

{% block content %}
<div class="wspr-page">
    <h1>WSPR Beacon Monitoring</h1>
    <p class="subtitle">Propagation tracking for AK6MJ beacon</p>

    <div class="card">
        <h2>Current Antenna</h2>
        <div id="antenna-selector">
            <div class="antenna-info" id="antenna-info">
                <div class="antenna-name" id="antenna-name">Loading...</div>
                <div class="antenna-desc" id="antenna-desc"></div>
                <div class="antenna-updated" id="antenna-updated"></div>
            </div>
            <div class="antenna-controls">
                <select id="antenna-select" class="form-control">
                    <option value="">Select antenna...</option>
                </select>
                <button id="update-antenna-btn" class="btn btn-primary btn-small" onclick="updateWSPRAntenna()">Update</button>
            </div>
        </div>
    </div>

    <div class="wspr-stats" id="stats">
        <div class="stat-card" id="beacon-status-card">
            <div class="stat-value" id="stat-band">-</div>
            <div class="stat-label">Beacon Band</div>
            <div class="stat-detail" id="stat-band-detail"></div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="stat-total">-</div>
            <div class="stat-label">Total Spots</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="stat-reporters">-</div>
            <div class="stat-label">Unique Reporters</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="stat-distance">-</div>
            <div class="stat-label">Max Distance (km)</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="stat-location">-</div>
            <div class="stat-label">TX Location</div>
        </div>
    </div>

    <div class="card">
        <h2>Propagation Map</h2>
        <div class="map-tabs">
            <button class="map-tab active" onclick="switchMapView('mercator')">Mercator</button>
            <button class="map-tab" onclick="switchMapView('azimuthal')">Azimuthal</button>
        </div>
        <div id="mercator-container" class="active">
            <div id="map"></div>
        </div>
        <div id="azimuthal-container">
            <div class="az-controls">
                <div class="az-slider-container">
                    <span class="az-slider-label">Range:</span>
                    <input type="range" id="az-zoom-slider" min="1000" max="20000" step="500" value="20000" oninput="azSliderChange(this.value)">
                    <span class="az-slider-label" id="az-range-label">20,000 km</span>
                </div>
                <button onclick="azReset()">Reset</button>
            </div>
            <div id="azimuthal-map"></div>
        </div>
        <p class="text-muted" id="last-update">Loading...</p>
    </div>

    <div class="card">
        <h2>Recent Spots</h2>
        <div id="spots-container">
            <p>Loading spots...</p>
        </div>
    </div>
</div>

<script>
// Initialize map
const map = L.map('map').setView([38.5, -98.0], 4);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

let txMarker = null;
let markers = [];

// Fetch and display WSPR data
async function loadWSPRData() {
    try {
        const response = await fetch('{{ url_for("main.api_wspr_spots") }}');
        const data = await response.json();

        // Clear existing markers
        markers.forEach(m => map.removeLayer(m));
        markers = [];
        if (txMarker) {
            map.removeLayer(txMarker);
            txMarker = null;
        }

        if (!data.spots || data.spots.length === 0) {
            document.getElementById('spots-container').innerHTML =
                '<p>No spots available. Beacon may be inactive or data not yet collected.</p>';
            document.getElementById('last-update').textContent =
                'Last updated: ' + (data.last_updated ? new Date(data.last_updated).toLocaleString() : 'Never');
            return;
        }

        // Update stats
        const uniqueReporters = new Set(data.spots.map(s => s.reporter)).size;
        const maxDistance = Math.max(...data.spots.map(s => s.distance_km || 0));

        document.getElementById('stat-total').textContent = data.spots.length;
        document.getElementById('stat-reporters').textContent = uniqueReporters;
        document.getElementById('stat-distance').textContent = Math.round(maxDistance);
        document.getElementById('stat-location').textContent = data.tx_grid || 'Unknown';
        document.getElementById('last-update').textContent =
            'Last updated: ' + new Date(data.last_updated).toLocaleString();

        // Add TX marker if we have grid
        if (data.tx_grid) {
            const txCoords = gridToLatLon(data.tx_grid);
            if (txCoords) {
                txMarker = L.marker(txCoords, {
                    icon: L.divIcon({
                        className: 'tx-marker',
                        html: '<div style="background: red; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white;"></div>'
                    })
                }).addTo(map).bindPopup(`<b>AK6MJ</b><br>${data.tx_grid}`);
                markers.push(txMarker);
            }
        }

        // Add reporter markers
        data.spots.forEach(spot => {
            const coords = gridToLatLon(spot.reporter_grid);
            if (coords) {
                const snrClass = spot.snr >= -15 ? 'snr-good' : spot.snr >= -25 ? 'snr-ok' : 'snr-weak';

                const marker = L.marker(coords).addTo(map).bindPopup(
                    `<b>${spot.reporter}</b><br>
                    Grid: ${spot.reporter_grid}<br>
                    SNR: <span class="${snrClass}">${spot.snr} dB</span><br>
                    Distance: ${Math.round(spot.distance_km)} km<br>
                    Bearing: ${spot.bearing_deg}°<br>
                    Frequency: ${spot.frequency} MHz<br>
                    Time: ${new Date(spot.timestamp).toLocaleString()}`
                );
                markers.push(marker);
            }
        });

        // Fit map to markers
        if (markers.length > 0) {
            const group = new L.featureGroup(markers);
            map.fitBounds(group.getBounds().pad(0.1));
        }

        // Cache data for azimuthal view
        cachedWSPRData = data;

        // Update azimuthal map if it's the active view
        if (currentMapView === 'azimuthal') {
            renderAzimuthalWSPR(data);
        }

        // Build spots table
        let html = '<table class="spots-table"><thead><tr>';
        html += '<th>Time</th><th>Reporter</th><th>Grid</th><th>SNR</th><th>Distance</th><th>Bearing</th><th>Frequency</th>';
        html += '</tr></thead><tbody>';

        data.spots.forEach(spot => {
            const snrClass = spot.snr >= -15 ? 'snr-good' : spot.snr >= -25 ? 'snr-ok' : 'snr-weak';
            const time = new Date(spot.timestamp).toLocaleTimeString();
            html += `<tr>
                <td>${time}</td>
                <td>${spot.reporter}</td>
                <td>${spot.reporter_grid}</td>
                <td class="${snrClass}">${spot.snr} dB</td>
                <td>${Math.round(spot.distance_km)} km</td>
                <td>${spot.bearing_deg}°</td>
                <td>${spot.frequency} MHz</td>
            </tr>`;
        });

        html += '</tbody></table>';
        document.getElementById('spots-container').innerHTML = html;

    } catch (error) {
        console.error('Error loading WSPR data:', error);
        document.getElementById('spots-container').innerHTML =
            '<p class="error">Error loading WSPR data. Check console for details.</p>';
    }
}

// Map view switching
let currentMapView = 'mercator';
let cachedWSPRData = null;

// Azimuthal zoom state - controls the km range shown
let azMaxDist = 20000;  // Start at 20,000 km (half Earth)
const AZ_MIN_DIST = 1000;   // Minimum 1,000 km
const AZ_MAX_DIST = 20000;  // Maximum 20,000 km

function updateAzSlider() {
    const slider = document.getElementById('az-zoom-slider');
    const label = document.getElementById('az-range-label');
    if (slider) slider.value = azMaxDist;
    if (label) label.textContent = azMaxDist >= 1000 ? (azMaxDist / 1000).toFixed(0) + ',000 km' : azMaxDist + ' km';
}

function azSliderChange(value) {
    azMaxDist = parseInt(value);
    updateAzSlider();
    if (cachedWSPRData) {
        renderAzimuthalWSPR(cachedWSPRData);
    }
}

function azZoom(factor) {
    azMaxDist = azMaxDist / factor;
    azMaxDist = Math.max(AZ_MIN_DIST, Math.min(AZ_MAX_DIST, azMaxDist));
    azMaxDist = Math.round(azMaxDist / 500) * 500; // Snap to 500km increments
    updateAzSlider();
    if (cachedWSPRData) {
        renderAzimuthalWSPR(cachedWSPRData);
    }
}

function azReset() {
    azMaxDist = 20000;
    updateAzSlider();
    if (cachedWSPRData) {
        renderAzimuthalWSPR(cachedWSPRData);
    }
}

// Initialize zoom handlers
function initAzPanZoom() {
    const container = document.getElementById('azimuthal-map');
    if (!container) return;

    container.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.3 : 0.77;
        azZoom(factor);
    });
}

function switchMapView(view) {
    currentMapView = view;
    document.querySelectorAll('.map-tab').forEach(tab => {
        tab.classList.toggle('active', tab.textContent.toLowerCase() === view);
    });
    document.getElementById('mercator-container').classList.toggle('active', view === 'mercator');
    document.getElementById('azimuthal-container').classList.toggle('active', view === 'azimuthal');

    if (view === 'azimuthal' && cachedWSPRData) {
        renderAzimuthalWSPR(cachedWSPRData);
    }
}

// Simplified continent outlines for azimuthal projection
const continentOutlines = [
    // North America
    [[-168,66],[-168,53],[-141,60],[-131,55],[-125,49],[-125,33],[-117,32],[-106,31],[-104,29],[-97,26],[-97,21],[-87,21],[-81,25],[-80,32],[-76,35],[-75,40],[-69,41],[-67,45],[-67,47],[-60,47],[-52,47],[-55,52],[-62,58],[-73,61],[-83,62],[-95,61],[-110,69],[-128,72],[-141,70],[-156,72],[-168,66]],
    // South America
    [[-81,8],[-77,9],[-72,12],[-62,11],[-52,5],[-35,5],[-35,-7],[-38,-15],[-42,-23],[-48,-28],[-54,-34],[-62,-39],[-65,-47],[-67,-56],[-73,-53],[-76,-46],[-75,-38],[-71,-30],[-70,-18],[-76,-5],[-80,0],[-81,8]],
    // Europe
    [[-10,36],[-6,37],[2,37],[5,44],[10,44],[15,40],[20,40],[27,42],[29,46],[22,55],[14,55],[10,60],[5,63],[10,70],[25,71],[31,70],[42,68],[42,56],[28,46],[30,41],[23,35],[20,35],[10,38],[0,35],[-10,36]],
    // Africa
    [[-17,15],[-17,21],[0,22],[10,32],[12,24],[33,32],[40,29],[43,12],[51,12],[51,-1],[40,-11],[35,-22],[27,-34],[18,-35],[12,-25],[8,-5],[-5,5],[-8,5],[-17,15]],
    // Asia
    [[42,68],[60,70],[95,77],[110,77],[180,66],[180,60],[170,60],[162,59],[147,44],[130,43],[120,33],[110,22],[102,22],[100,14],[95,6],[80,8],[77,23],[68,24],[62,25],[50,30],[40,29],[33,32],[36,37],[27,42],[42,56],[42,68]],
    // Southeast Asia
    [[95,6],[100,1],[104,-6],[115,-8],[130,-8],[141,-6],[141,-10],[131,-12],[115,-11],[106,0],[100,6],[95,6]],
    // Australia
    [[113,-22],[114,-26],[116,-35],[130,-32],[138,-34],[141,-39],[147,-39],[154,-28],[153,-20],[145,-15],[142,-11],[136,-12],[129,-15],[122,-18],[114,-20],[113,-22]],
    // Japan
    [[129,33],[131,34],[132,35],[135,35],[138,36],[140,40],[141,43],[145,44],[145,42],[141,39],[140,36],[137,35],[130,32],[129,33]],
    // UK/Ireland
    [[-10,51],[-5,50],[2,51],[2,55],[-2,57],[-5,58],[-7,58],[-10,54],[-10,51]],
    // New Zealand
    [[166,-47],[168,-44],[175,-41],[178,-37],[178,-34],[174,-35],[172,-40],[166,-47]]
];

// Azimuthal equidistant projection
function azimuthalProject(lat, lon, centerLat, centerLon, maxRadius, maxDistKm) {
    const R = 6371;
    const lat1 = centerLat * Math.PI / 180;
    const lat2 = lat * Math.PI / 180;
    const dLon = (lon - centerLon) * Math.PI / 180;

    const c = Math.acos(Math.sin(lat1) * Math.sin(lat2) +
                        Math.cos(lat1) * Math.cos(lat2) * Math.cos(dLon));
    const dist = R * c;

    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    const bearing = Math.atan2(y, x);

    const r = (dist / maxDistKm) * maxRadius;
    const screenX = r * Math.sin(bearing);
    const screenY = -r * Math.cos(bearing);

    return { x: screenX, y: screenY, dist: dist };
}

// Render azimuthal WSPR map
function renderAzimuthalWSPR(data) {
    const container = document.getElementById('azimuthal-map');
    if (!data || !data.spots || data.spots.length === 0) {
        container.innerHTML = '<p>No spot data available.</p>';
        return;
    }

    // Get QTH coordinates from tx_grid
    const txGrid = data.tx_grid || 'CM98';
    const txCoords = gridToLatLon(txGrid);
    if (!txCoords) {
        container.innerHTML = '<p>Unable to determine TX location.</p>';
        return;
    }
    const [centerLat, centerLon] = txCoords;

    // SVG dimensions - use viewBox for responsive sizing
    const size = 700;
    const cx = size / 2;
    const cy = size / 2;
    const maxRadius = size / 2 - 40;
    const maxDist = azMaxDist; // Use current zoom level
    const distScale = maxRadius / maxDist;

    // Responsive SVG that fills container width (up to max)
    let svg = `<svg viewBox="0 0 ${size} ${size}" style="width: 100%; max-width: ${size}px; height: auto;">`;

    // Background
    svg += `<circle cx="${cx}" cy="${cy}" r="${maxRadius}" fill="#1a1a2e" stroke="#333"/>`;

    // Draw continent outlines (only when zoomed out enough to avoid clipping artifacts)
    if (maxDist >= 8000) {
        for (const outline of continentOutlines) {
            let pathParts = [];
            let allInBounds = true;
            let anyInBounds = false;

            for (let i = 0; i < outline.length; i++) {
                const [lon, lat] = outline[i];
                const proj = azimuthalProject(lat, lon, centerLat, centerLon, maxRadius, maxDist);
                const px = cx + proj.x;
                const py = cy + proj.y;
                const inBounds = proj.dist <= maxDist;

                if (!inBounds) allInBounds = false;
                if (inBounds) anyInBounds = true;

                if (i === 0) {
                    pathParts.push(`M${px.toFixed(1)},${py.toFixed(1)}`);
                } else {
                    pathParts.push(`L${px.toFixed(1)},${py.toFixed(1)}`);
                }
            }

            // Only draw if all points are in bounds (avoids clipping artifacts)
            if (allInBounds && pathParts.length > 2) {
                svg += `<path d="${pathParts.join(' ')} Z" fill="#1e3a2d" fill-opacity="0.25" stroke="#3a5a4a" stroke-width="0.5" opacity="0.7"/>`;
            }
        }
    }

    // Distance rings - dynamic based on zoom level
    const ringIntervals = maxDist <= 2000 ? [500, 1000, 1500, 2000] :
                          maxDist <= 5000 ? [1000, 2000, 3000, 4000, 5000] :
                          maxDist <= 10000 ? [2000, 4000, 6000, 8000, 10000] :
                          [5000, 10000, 15000, 20000];
    for (const dist of ringIntervals) {
        const r = dist * distScale;
        if (r > 0 && r <= maxRadius) {
            svg += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="#333" stroke-dasharray="4,4"/>`;
            svg += `<text x="${cx + 5}" y="${cy - r + 12}" fill="#555" font-size="10">${dist >= 1000 ? (dist/1000).toFixed(0) + 'k' : dist} km</text>`;
        }
    }

    // Direction labels and lines
    const dirs = [{a: 0, l: 'N'}, {a: 45, l: 'NE'}, {a: 90, l: 'E'}, {a: 135, l: 'SE'},
                  {a: 180, l: 'S'}, {a: 225, l: 'SW'}, {a: 270, l: 'W'}, {a: 315, l: 'NW'}];
    for (const d of dirs) {
        const rad = (d.a - 90) * Math.PI / 180;
        const lx = cx + (maxRadius + 20) * Math.cos(rad);
        const ly = cy + (maxRadius + 20) * Math.sin(rad);
        svg += `<text x="${lx}" y="${ly}" fill="#666" font-size="12" text-anchor="middle" dominant-baseline="middle">${d.l}</text>`;
        const x2 = cx + maxRadius * Math.cos(rad);
        const y2 = cy + maxRadius * Math.sin(rad);
        svg += `<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" stroke="#333" stroke-width="1"/>`;
    }

    // SNR color scale
    function snrToColor(snr) {
        if (snr >= -10) return '#16a34a';  // Strong - green
        if (snr >= -20) return '#ca8a04';  // OK - yellow
        return '#dc2626';  // Weak - red
    }

    // Draw lines and spots
    for (const spot of data.spots) {
        const coords = gridToLatLon(spot.reporter_grid);
        if (!coords) continue;

        const [lat, lon] = coords;
        const proj = azimuthalProject(lat, lon, centerLat, centerLon, maxRadius, maxDist);
        const x = cx + proj.x;
        const y = cy + proj.y;

        if (proj.dist > maxDist) continue;

        const color = snrToColor(spot.snr);

        // Line from QTH to spot
        svg += `<line x1="${cx}" y1="${cy}" x2="${x}" y2="${y}" stroke="${color}" stroke-width="1" stroke-opacity="0.3"/>`;

        // Spot marker
        const tooltip = `${spot.reporter} (${spot.reporter_grid})\nSNR: ${spot.snr} dB\nDistance: ${Math.round(spot.distance_km)} km\nBearing: ${spot.bearing_deg}\u00b0`;
        svg += `<circle cx="${x}" cy="${y}" r="5" fill="${color}" stroke="#fff" stroke-width="1">
            <title>${tooltip}</title>
        </circle>`;
    }

    // Center point (QTH)
    svg += `<circle cx="${cx}" cy="${cy}" r="8" fill="#ff0000" stroke="#fff" stroke-width="2"/>`;
    svg += `<text x="${cx}" y="${cy - 15}" fill="#fff" font-size="11" text-anchor="middle" font-weight="bold">AK6MJ</text>`;
    svg += `<text x="${cx}" y="${cy + 25}" fill="#aaa" font-size="10" text-anchor="middle">${txGrid}</text>`;

    // Legend
    svg += `<g transform="translate(${size - 100}, 30)">
        <text x="0" y="0" fill="#888" font-size="11">SNR Legend</text>
        <circle cx="10" cy="18" r="5" fill="#16a34a"/><text x="22" y="22" fill="#aaa" font-size="10">> -10 dB</text>
        <circle cx="10" cy="36" r="5" fill="#ca8a04"/><text x="22" y="40" fill="#aaa" font-size="10">-10 to -20</text>
        <circle cx="10" cy="54" r="5" fill="#dc2626"/><text x="22" y="58" fill="#aaa" font-size="10">< -20 dB</text>
    </g>`;

    svg += '</svg>';
    container.innerHTML = svg;
}

// Maidenhead grid to lat/lon converter (supports 4 and 6 character grids)
function gridToLatLon(grid) {
    if (!grid || grid.length < 4) return null;

    grid = grid.toUpperCase();
    let lon = (grid.charCodeAt(0) - 65) * 20 - 180 + (grid.charCodeAt(2) - 48) * 2;
    let lat = (grid.charCodeAt(1) - 65) * 10 - 90 + (grid.charCodeAt(3) - 48);

    // Handle 6-char grids with subsquare
    if (grid.length >= 6) {
        lon += (grid.charCodeAt(4) - 65) * (2/24) + (1/24);
        lat += (grid.charCodeAt(5) - 65) * (1/24) + (1/48);
    } else {
        // For 4-char grids, return center of square
        lon += 1;
        lat += 0.5;
    }

    return [lat, lon];
}

// Load current WSPR antenna
async function loadWSPRAntenna() {
    try {
        const response = await fetch('{{ url_for("main.api_wspr_antenna_get") }}');
        const data = await response.json();

        if (data.antenna) {
            document.getElementById('antenna-name').textContent = data.antenna;
            document.getElementById('antenna-desc').textContent = data.description || '';
            if (data.last_updated) {
                const updated = new Date(data.last_updated);
                document.getElementById('antenna-updated').textContent =
                    'Updated: ' + updated.toLocaleString();
            }
        } else {
            document.getElementById('antenna-name').textContent = 'Not configured';
            document.getElementById('antenna-desc').textContent = '';
            document.getElementById('antenna-updated').textContent = '';
        }
    } catch (error) {
        console.error('Failed to load WSPR antenna:', error);
        document.getElementById('antenna-name').textContent = 'Error loading antenna';
    }
}

// Load available antennas for selector
async function loadAntennas() {
    try {
        const response = await fetch('{{ url_for("main.api_antennas_list") }}');
        const antennas = await response.json();

        const select = document.getElementById('antenna-select');
        select.innerHTML = '<option value="">Select antenna...</option>';

        for (const [label, info] of Object.entries(antennas)) {
            const option = document.createElement('option');
            option.value = label;
            option.textContent = `${label} - ${info.description.substring(0, 50)}...`;
            select.appendChild(option);
        }
    } catch (error) {
        console.error('Failed to load antennas:', error);
    }
}

// Update WSPR antenna
async function updateWSPRAntenna() {
    const select = document.getElementById('antenna-select');
    const antenna = select.value;

    if (!antenna) {
        alert('Please select an antenna');
        return;
    }

    const btn = document.getElementById('update-antenna-btn');
    btn.disabled = true;
    btn.textContent = 'Updating...';

    try {
        const response = await fetch('{{ url_for("main.api_wspr_antenna_set") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ antenna: antenna })
        });

        if (!response.ok) {
            throw new Error('Failed to update antenna');
        }

        // Reload antenna display
        await loadWSPRAntenna();

        // Reset selector
        select.value = '';
        alert('WSPR antenna updated successfully');

    } catch (error) {
        console.error('Failed to update antenna:', error);
        alert('Failed to update antenna: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Update';
    }
}

// Load beacon status (band, frequency, etc)
async function loadBeaconStatus() {
    const card = document.getElementById('beacon-status-card');
    const bandEl = document.getElementById('stat-band');
    const detailEl = document.getElementById('stat-band-detail');

    try {
        const response = await fetch('{{ url_for("main.api_wspr_beacon") }}');
        const data = await response.json();

        if (data.status === 'unknown' || data.error) {
            bandEl.textContent = '?';
            detailEl.textContent = 'Beacon offline or unreachable';
            card.className = 'stat-card beacon-offline';
        } else if (data.stale) {
            bandEl.textContent = data.band || '?';
            detailEl.textContent = `Stale (${Math.round(data.age_minutes)}min ago)`;
            card.className = 'stat-card beacon-stale';
        } else {
            bandEl.textContent = data.band;
            detailEl.textContent = `${data.pool} pool`;
            card.className = 'stat-card beacon-active';
        }
    } catch (error) {
        console.error('Failed to load beacon status:', error);
        bandEl.textContent = '?';
        detailEl.textContent = 'Error loading status';
        card.className = 'stat-card beacon-offline';
    }
}

// Load data on page load
loadBeaconStatus();
loadWSPRAntenna();
loadAntennas();
loadWSPRData();
initAzPanZoom();

// Refresh every 5 minutes
setInterval(loadWSPRData, 5 * 60 * 1000);
setInterval(loadBeaconStatus, 60 * 1000);  // Refresh beacon status every minute
</script>
{% endblock %}
